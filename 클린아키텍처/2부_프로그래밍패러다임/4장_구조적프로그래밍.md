# 4장. 구조적 프로그래밍

### 다익스트라

- 프로그래밍에 대한 지적 도전이 이론 물리에 대한 지적 도전보다 더 큰 의미가 있다는 결론을 내렸다.
- 진공관 시대에 경력을 시작했는데, 원시적인 환경에서 위대한 발견을 해냈다.

### 증명(proof)

- 문제 : 모든 프로그램은 단순할지라도 인간 두뇌로 감당하기엔 너무 많은 세부사항을 담고 있었다.
- 해결 : 다익스트라는 **증명이라는 수학적 원리**를 적용해 이 문제를 해결하고자 했다.
  - 유클리드 계층구조(공리, 정리, 따름정리, 보조정리로 구성) 만들고자함
  - goto문이 모듈을 재귀적으로 분해할 때 방해가 되기도 하는 것을 발견
    - 모듈 분해하지 못하면, 분할정복 접근법 사용 불가
  - goto문을 써도 모듈 분해에 문제가 되지 않는 경우도 존재
    - 분기(if/then/else), 반복(do/while) 제어구조 사용으로 재귀적 세분화 가능하도록함
      - 이런 제어구조는 순차실행과 결합했을 때 특별하다는 사실도 깨달음
- 뵘(Bohm), 야코피니(Jacopini)
  - **모든 프로그램은 순차, 분기, 반복 세 가지 구조만으로 표현할 수 있음을 증명**

### 해로운 성명서

> 다익스트라는 CACM 편집자에게 편지를 썼고, 편지의 제목은 "goto문의 해로움"이었다. 이 글에서 세 가지 제어 구조에 대한 자신의 의견을 피력했다. 그렇게 전쟁은 시작되었고, 결국 이 전쟁은 10년 이상 지속되었다.

- 컴퓨터 언어가 진화하면서 goto문은 계속 뒤편으로 밀려났고, 마침내 거의 사라졌다.
- 현재 우리 모두는 **구조적 프로그래머**이며, 선택의 여지가 없다.
  - 제어흐름을 제약없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.
    - label붙인 break 등이 goto와 유사하지만, 제약없이 직접 전환하던 이전 언어와 달리, 구조에 어느정도 제한이 있다.

### 기능적 분해

> 구조적 프로그래밍을 통해, 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.

- 기능을 재귀적으로 분해
  - 구조적 분석, 구조적 설계 가능해짐
  - 대규모 시스템을 모듈, 컴포넌트로 쪼갤 수 있게 됨

### 과학이 구출하다.

- 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 ㅇ낳았다.
- 대신, 과학적 방법이 있다.
  - 과학적 방법 : 반증은 가능하지만 증명은 불가능
    - 시연, 측정은 가능하지만, 수학적으로 증명할 수는 없음
    - 서술된 내용이 사실임을 증명 X, 서술이 틀렸음을 증명 O

### 테스트

> "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다." - 다익스트라

- 프로그램이 잘못됨을 증명할 수는 있지만, 맞다고 증명할 수는 없다.
  - 충분히 참이라고 여길 수 있게 해주는 것이 전부다.

> 소프트웨어 개발은 수학적인 시도가 아니다. 오히려 과학과 같다. 최선을 다해도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.

- 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 분해할 것을 강조한다.
  - 이후에 테스트를 통해 증명 가능한 세부기능들이 거짓인지를 증명하려고 시도한다.
  - 거짓임을 증명하는 테스트가 실패하면, 충분히 참이라고 여긴다.

### 결론

> 구조적 프로그래밍이 오늘날까지 가치 있는 이유는, 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.

- 작은 기능 ~ 큰 컴포넌트까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성(테스트)에 의해 주도된다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 테스트되도록 만들어야 한다.
  - 이를 위해 제한적인 규칙들을 받아들여 적용해야 한다.
